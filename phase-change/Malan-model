//Date: 02/04/2020
/********************************************************* mass transfer rate calculation ********************************/
/**************************************************** mass-transfer model-1 (Leon Malan) ********************************************/ 
/*
The stencil in Basilisk is 3*3 by default. Under this circumastance, we use neighbor cell and diagonal neighbor cell (pure cell) to calculate mass transfer rate by weighted average method.
1). Basilisk uses geometric VOF method, the reconstruction of interface in one computational cell uses PLIC method, therefore we can index several functions in 'fractions.h'
$ interface normal -> interface_normal(point,f) f here indicates the color function of volume fraction of reference fluid
$ distance from cell center to interface -> alpha = plane_alpha (f[], n)
$ considering closest neighbor cell -> interfacial(neighborp(-1),f); this is two closest neighboring cells around interface in x direction, if you want to use in y direction, change to neighborp(0,-1)
$ diagonal neighboring cell (like f[1,1],f[1,-1],f[-1,1],f[-1,-1]) -> interfacial(neighbor(-1,-1),f); it depends on your test case to change the location of the diagonal cell.

2). The precondition of this model is to assume the interface at saturated temperature, so we have to calculate four values to get the temperature gradient of target cell.
$ The distance for neighboring cells' center to targeted interface is calculated as follows:
->  
    Because there are four circumastances for the direction of interface x and y, they are ((n.x>0,n.y>0);(n.x>0,n.y<0);(n.x<0,n.y>0);(n.x<0,n.y<0)), for each case, the calculation of distance
    has a little difference, so we need to consider every case as follows:

    vector n[];
    compute_normal (f, n);// the interface normal vector

    -> if (interfacial(neighborp(-1), f)||interfacial(neighborp(-1,-1), f)||interfacial(neighborp(1,1), f) ) {
        coord nf;
        foreach_dimension()
            nf.x = 0.;
        if (interfacial(point, f)) {
            foreach_dimension()
            nf.x += n.x[];
        }
        if (interfacial(neighborp(-1), f)) {
            nf.x += n.x[-1];
            nf.y += n.y[-1];
        }

        if (interfacial(neighborp(-1,-1), f)) {
            nf.x += n.x[-1,-1];
            nf.y += n.y[-1,-1];
        }

        if (interfacial(neighborp(1,1), f)) {
            nf.x += n.x[1,1];
            nf.y += n.y[1,1];
        }    

        double norm = 0.;
        foreach_dimension()
            norm += fabs(nf.x);
        foreach_dimension()
            nf.x /= (tr.inverse ? -norm : norm);
    

->  if(interfacial(point,f))
    {
        alpha = plane_alpha(f[],n);
    }

    else if(interfacial(neighborp(-1))
    {
        alpha = plane_alpha(f[],n)*Delta/sqrt(sq(n.x) + sq(n.y)) + 0.5*(n.x + n.y)*Delta;
    }
    else if(interfacial(neighborp(-1,-1))||interfacial(neighborp(1,1),f))
    {
        alpha = plane_alpha(f[],n)*Delta/sqrt(sq(n.x) + sq(n.y)) + 0.5*n.x*Delta + 1.5*n.y*Delta;
    }

    //alpha = alpha*Delta/(sq(n.x) + sq(n.y)); // normalize the distance


$ The heat flux required now to compute phase change by using weighted average of neighbor cell and diagonal cell
->  double gamma = 0;
    if(interfacial(neighborp(-1),f)){
        gamma = fabs(0.5*(n.x + n.y))/(sq(0.5)+sq(0.5));
    }
    else if(interfacial(neighborp(-1,-1),f)||interfacial(neighborp(1,1),f))
    {
        gamma = fabs(0.5*n.x + 1.5*n.y)/(sq(0.5)+sq(1.5));
    }
->  // calculate the mass transfer rate
    scalar mass_rate[];
    foreach(reduction(+:max)){
        mass_rate[] += gamma*(T[] - T_sat)/alpha;
    }
    boundary({mass_rate});


/******************************************* mass transfer model-2 (Lee model) *******************************************************/
/*
The Lee model is an empirical expression to calculate mass transfer rate, there is one prediction value a to control the value of mass tranfer rate to satisfy the analytical solution.

->   foreach(){
        if (interfacial(point,f))
            m[] = -0.1*tr.rho*(T[] - T_sat)/T_sat*(T.inverse?f[]:1-f[]);
        else
            m[] = 0;
        }
*/

/*************************************************************************************************************************************************/
/************************************************** Geometric VOF method account for phase-change ************************************************/
/*
The general geometric VOF method in Basilisk can be divided in two steps:
1). interface reconstruction
-> using levelset function to compute volume fraction first (obtain c)
-> using function 'plane_alpha(c,n)' to calculate interface distance
2). interface advection
-> the conservative convection term can be expressed as: \nabla \cdot (uf*c) - cc*(\nabla \cdot uf)
    the vof flux (uf*c) should be computed first and the velocity and c at initial time used here, in order to keep conservation, WY scheme used.
One should be noted the face velocity here obey the divergence-free rule, which means: \nabla \cdot \vec{uf} = 0, however, if we consider phase-change, the velocity divergence at interface not equals to zero.
Therefore, we need to other methods to gurantee the interface shift in divergence-free velocity domain.

The Malan's scheme is modified on the general geometric VOF method, but change the interface advection step by adding provisional volume fraction, as follows:
-> SUB-DOMAIN around interface construction
    In the first step, one sub-domain should be constructed around interface, the objective of this is to make sure the divergence of velocity is zero, then using the conservative vof method.
                                            /***********ã€€sub-domain method *************/
/*
The sub-domain is composed of interfacial cell and neighbor cell&& diagonal cell mentioned above.
1). Boundary conditions
The liquid side of interface by defining all the cell faces between mixed and liquid cells as domain boundary on which a no-slip boundary condition is applied.
*/
/************************************ not solved *************************/
/*
Some attempts have been done. 
-> /*************** foreach_boundary() *****************/
/*
It is sometimes useful to be able to traverse only the cells which are touching a given boundary, for example to compute surface fluxes and other diagnostics. 
While using a combination of foreach() and conditions on cell coordinates would be possible, it would also be inefficient and could be difficult when using adaptive meshes. 
For this reason, Basilisk provides the foreach_boundary() iterator.
    // no-slip boundary condition at the cell edge adjacent liquid cell and mixed cell. Tangential velocity is equal to zero.
    -> foreach_boundary(left){
        u.y[] = 0;
    }
        foreach_boundary(bottom){
            u.x[] = 0;
        }
    // free-flow faces (slip boundary condition)
    /*************************/
    /*
        Here we use one trick to make the divergence velocity in diagonal cell equals zero (including neighborp(1,1) and neighborp(-1,-1)).
            scalar div[]; // divergence of liquid velocity
            foreach(){
                if(interfacial(neighborp(1,1),f)||interfacial(neighborp(-1,-1),f))
                    div[] = 0;
                else
                    div[] = (uf_l[1] - uf_l[])/Delta;
            }
            boundary({div});

    -> foreach_boundary(right){
        u.x[] = 0;
    }
        foreach_boundary(top){
            u.y[] = 0;
        }
*/
-> /************************* Conventional boundary conditions by limit the sub-domain ***************************/
/*
    p[right] = (f[] < 1 - 1e-5&&interfacial(point, f)?p_new[]:dirichlet(0.));
    p[top] = (f[] < 1 - 1e-5&&interfacial(point, f)?p_new[]:dirichlet(0.));
    u.n[right] = ((f[] < 1 - 1e-5&&interfacial(neighborp(-1,-1), f))?0:neumann(0.));
    u.n[top] = ((f[] < 1 - 1e-5&&interfacial(neighborp(-1,-1), f))?0:neumann(0.));
    u.t[bottom] = (interfacial(point, f)?dirichlet(0.):0);
    u.t[left] = (interfacial(point, f)?dirichlet(0.):0);

2). After constructing the sub-domain, we need to solve Poisson equation to obtain the provisional pressure in this domain through adding mass source in Poisson equation.
-> p*
-> using p* to get the provisional velocity in sub-domain uf*
-> the liquid velocity: uf_l = u^{n+1} + uf* // here u^{n+1} comes from the genral projection method by solving NS equations with mass source at interface.
    here we need to transfer the face velocity in 'vof.h'  to uf_l
-> now we construct the divergence-free velocity in entire domain, liquid domain including subdomain
    \nabla \cdot uf_l = \nabla \cdot u^{n+1} + \nabla \cot uf* = 0
*/
/************************************* Shifting the interface to account for phase change **************************************/
/*
-> foreach()
  {
    if(interfacial(point,f)){
      //
      coord n = normal(point,f); // interface normal
      double alpha = plane_alpha(f[],n); // distance from original point to interface 
      alpha -= m[]*dt/(rho2*Delta)*sqrt(sq(n.x)+sq(n.y)); // phase-change shifting distance
      f[] = line_area(n.x,n.y,alpha); // cell volume fraction for n+1
    }
  }
*/


/************************************************** Energy conservation considering heat source *************************************/
/* Date: 03/04/2020
Here we introduce two simple models to account for phase change in energy equation.

/******************************* Interface equalibrium model **********************************/
/*
One simple method to keep 
*/
